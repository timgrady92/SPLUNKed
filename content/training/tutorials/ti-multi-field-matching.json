{
  "id": "ti-multi-field-matching",
  "type": "tutorial",
  "title": "Multi-Field IOC Matching",
  "description": "Match IOCs across multiple fields simultaneously, handle CIDR ranges for IP addresses, implement wildcard matching for domains, and build comprehensive threat detection queries.",
  "category": "threat-intel",
  "difficulty": "advanced",
  "duration": "25 min",
  "tags": ["threat-intel", "matching", "cidr", "wildcard", "advanced"],
  "objectives": [
    "Match IOCs across multiple event fields",
    "Implement CIDR range matching for IP indicators",
    "Use wildcard matching for domain indicators",
    "Build comprehensive multi-source TI queries"
  ],
  "content": {
    "sections": [
      {
        "title": "Why Multi-Field Matching?",
        "body": "<p>Security events contain multiple IOC-relevant fields. Comprehensive detection requires checking all of them.</p><h4>Common Multi-Field Scenarios</h4><table><tr><th>Data Source</th><th>Fields to Check</th></tr><tr><td>Firewall</td><td>src_ip, dest_ip, src_port, dest_port</td></tr><tr><td>DNS</td><td>query, answer, src_ip</td></tr><tr><td>Proxy</td><td>src_ip, dest, url, user_agent</td></tr><tr><td>Email</td><td>sender, recipient, subject, attachment_hash, url</td></tr><tr><td>Endpoint</td><td>file_hash, file_path, parent_process, command_line</td></tr></table><h4>The Challenge</h4><p>A single lookup call checks one field. Multi-field matching requires multiple lookups or creative approaches.</p>"
      },
      {
        "title": "Sequential Lookup Approach",
        "body": "<h4>Multiple Lookups, Different Fields</h4><pre><code>index=firewall\n| lookup threat_ips indicator as src_ip OUTPUT \n    threat_type as src_threat,\n    confidence as src_confidence,\n    category as src_category\n| lookup threat_ips indicator as dest_ip OUTPUT \n    threat_type as dest_threat,\n    confidence as dest_confidence,\n    category as dest_category\n| where isnotnull(src_threat) OR isnotnull(dest_threat)\n| eval threat_direction = case(\n    isnotnull(src_threat) AND isnotnull(dest_threat), \"bidirectional\",\n    isnotnull(src_threat), \"inbound_from_threat\",\n    isnotnull(dest_threat), \"outbound_to_threat\")\n| table _time, src_ip, src_threat, dest_ip, dest_threat, threat_direction</code></pre><h4>Mixed IOC Type Matching</h4><pre><code>index=proxy\n| lookup threat_ips indicator as src_ip OUTPUT threat_type as ip_threat\n| lookup threat_domains indicator as dest OUTPUT threat_type as domain_threat\n| lookup threat_urls indicator as url OUTPUT threat_type as url_threat\n| where isnotnull(ip_threat) OR isnotnull(domain_threat) OR isnotnull(url_threat)\n| eval matched_ioc = coalesce(\n    if(isnotnull(ip_threat), src_ip, null()),\n    if(isnotnull(domain_threat), dest, null()),\n    if(isnotnull(url_threat), url, null()))\n| eval matched_type = coalesce(ip_threat, domain_threat, url_threat)\n| table _time, user, matched_ioc, matched_type</code></pre>"
      },
      {
        "title": "CIDR Range Matching",
        "body": "<p>Match IPs against CIDR ranges instead of exact IPs.</p><h4>Configure CIDR Lookup</h4><p>In transforms.conf:</p><pre><code>[threat_ip_ranges]\nfilename = threat_ip_ranges.csv\nmatch_type = CIDR(cidr_range)</code></pre><p>Lookup file:</p><pre><code>cidr_range,threat_type,confidence,description\n192.168.50.0/24,c2,high,\"Known C2 range\"\n10.0.0.0/8,internal,info,\"Internal range\"\n103.224.182.0/24,tor_exit,medium,\"Tor exit nodes\"</code></pre><h4>Using CIDR Lookup</h4><pre><code>index=firewall\n| lookup threat_ip_ranges cidr_range as dest_ip OUTPUT threat_type, confidence\n| where isnotnull(threat_type) AND threat_type != \"internal\"\n| table _time, src_ip, dest_ip, threat_type, confidence</code></pre><h4>Inline CIDR Matching</h4><p>Without pre-configured lookup:</p><pre><code>index=firewall\n| where cidrmatch(\"192.168.50.0/24\", dest_ip) OR cidrmatch(\"103.224.182.0/24\", dest_ip)\n| eval threat_type = case(\n    cidrmatch(\"192.168.50.0/24\", dest_ip), \"c2_range\",\n    cidrmatch(\"103.224.182.0/24\", dest_ip), \"tor_exit\")</code></pre><h4>Multiple CIDR Checks</h4><pre><code>index=firewall\n| lookup threat_ip_ranges cidr_range as src_ip OUTPUT threat_type as src_range_threat\n| lookup threat_ip_ranges cidr_range as dest_ip OUTPUT threat_type as dest_range_threat\n| where isnotnull(src_range_threat) OR isnotnull(dest_range_threat)</code></pre>"
      },
      {
        "title": "Wildcard Domain Matching",
        "body": "<h4>Configure Wildcard Lookup</h4><p>In transforms.conf:</p><pre><code>[threat_domains_wildcard]\nfilename = threat_domains.csv\nmatch_type = WILDCARD(domain)</code></pre><p>Lookup file with wildcards:</p><pre><code>domain,threat_type,confidence\n*.evil.com,c2,high\nmalware-*.net,malware,medium\n*.ru,suspicious,low\nexact.bad.com,phishing,high</code></pre><h4>Using Wildcard Lookup</h4><pre><code>index=dns\n| lookup threat_domains_wildcard domain as query OUTPUT threat_type, confidence\n| where isnotnull(threat_type)\n| table _time, src_ip, query, threat_type, confidence</code></pre><h4>Regex-Based Domain Matching</h4><p>For complex patterns not supported by WILDCARD:</p><pre><code>index=dns\n| where match(query, \"(?i)^[a-z0-9]{20,}\\\\.evil\\\\.com$\")\n| eval threat_type = \"dga_domain\"\n| table _time, src_ip, query, threat_type</code></pre><h4>Subdomain Extraction and Matching</h4><pre><code>index=dns\n| rex field=query \"(?&lt;root_domain&gt;[^.]+\\\\.[^.]+)$\"\n| lookup threat_domains domain as root_domain OUTPUT threat_type\n| where isnotnull(threat_type)\n| table _time, src_ip, query, root_domain, threat_type</code></pre>"
      },
      {
        "title": "Universal IOC Field Pattern",
        "body": "<h4>Coalesce for Universal Matching</h4><p>Create a single field to match against:</p><pre><code>index=firewall OR index=dns OR index=proxy\n| eval ioc_candidate = coalesce(dest_ip, src_ip, query, dest, url_domain)\n| lookup universal_iocs indicator as ioc_candidate OUTPUT threat_type, ioc_type\n| where isnotnull(threat_type)\n| table _time, index, ioc_candidate, ioc_type, threat_type</code></pre><h4>Multi-Value Field for Comprehensive Checking</h4><pre><code>index=firewall\n| eval check_values = mvappend(src_ip, dest_ip)\n| mvexpand check_values\n| lookup threat_ips indicator as check_values OUTPUT threat_type\n| where isnotnull(threat_type)\n| stats values(check_values) as matched_ips, values(threat_type) as threats by _time, src_ip, dest_ip</code></pre><h4>All-Fields IOC Sweep</h4><pre><code>index=proxy\n| eval all_indicators = mvappend(src_ip, dest, url_domain, user_agent)\n| mvexpand all_indicators\n| lookup universal_iocs indicator as all_indicators OUTPUT threat_type, ioc_type\n| where isnotnull(threat_type)\n| stats values(all_indicators) as matched_indicators, values(threat_type) as threat_types by _time, user</code></pre>"
      },
      {
        "title": "DNS-Specific Patterns",
        "body": "<h4>Query and Answer Matching</h4><pre><code>index=dns\n| lookup threat_domains domain as query OUTPUT threat_type as query_threat\n| lookup threat_ips indicator as answer OUTPUT threat_type as answer_threat\n| where isnotnull(query_threat) OR isnotnull(answer_threat)\n| eval match_type = case(\n    isnotnull(query_threat) AND isnotnull(answer_threat), \"both\",\n    isnotnull(query_threat), \"malicious_domain\",\n    isnotnull(answer_threat), \"malicious_resolution\")</code></pre><h4>DNS Response to Known Bad IP</h4><pre><code>index=dns reply_code=NOERROR\n| lookup threat_ips indicator as answer OUTPUT threat_type\n| where isnotnull(threat_type)\n| table _time, src_ip, query, answer, threat_type</code></pre><p>This finds domains resolving to known bad IPs - potentially newly registered malicious domains.</p><h4>Bulk DNS IOC Check</h4><pre><code>| inputlookup threat_domains.csv\n| map maxsearches=500 search=\"index=dns query=$domain$ earliest=-24h | head 1 | eval domain=\\\"$domain$\\\"\"\n| stats count by domain, src_ip\n| where count > 0</code></pre>"
      },
      {
        "title": "Email-Specific Patterns",
        "body": "<h4>Comprehensive Email IOC Check</h4><pre><code>index=email\n| rex field=sender \"@(?&lt;sender_domain&gt;.+)$\"\n| lookup threat_emails indicator as sender OUTPUT threat_type as sender_threat\n| lookup threat_domains indicator as sender_domain OUTPUT threat_type as domain_threat\n| lookup threat_urls indicator as url OUTPUT threat_type as url_threat\n| lookup threat_hashes indicator as attachment_hash OUTPUT threat_type as hash_threat\n| where isnotnull(sender_threat) OR isnotnull(domain_threat) OR isnotnull(url_threat) OR isnotnull(hash_threat)\n| eval matched_indicator = coalesce(\n    if(isnotnull(sender_threat), sender, null()),\n    if(isnotnull(domain_threat), sender_domain, null()),\n    if(isnotnull(url_threat), url, null()),\n    if(isnotnull(hash_threat), attachment_hash, null()))\n| table _time, recipient, sender, subject, matched_indicator, threat_type</code></pre><h4>Attachment Hash Matching</h4><pre><code>index=email attachment_hash=*\n| lookup threat_hashes indicator as attachment_hash OUTPUT malware_family, confidence\n| where isnotnull(malware_family)\n| table _time, sender, recipient, attachment_name, malware_family, confidence</code></pre>"
      },
      {
        "title": "Endpoint-Specific Patterns",
        "body": "<h4>Process and File IOC Matching</h4><pre><code>index=sysmon EventCode=1\n| rex field=Hashes \"SHA256=(?&lt;sha256&gt;[A-Fa-f0-9]{64})\"\n| rex field=Hashes \"MD5=(?&lt;md5&gt;[A-Fa-f0-9]{32})\"\n| lookup threat_hashes indicator as sha256 OUTPUT threat_type as sha_threat, malware_family\n| lookup threat_hashes indicator as md5 OUTPUT threat_type as md5_threat\n| lookup threat_ips indicator as DestinationIp OUTPUT threat_type as ip_threat\n| where isnotnull(sha_threat) OR isnotnull(md5_threat) OR isnotnull(ip_threat)\n| table _time, User, Image, sha256, malware_family, DestinationIp, ip_threat</code></pre><h4>Parent-Child with IOC Context</h4><pre><code>index=sysmon EventCode=1\n| rex field=Hashes \"SHA256=(?&lt;sha256&gt;[A-Fa-f0-9]{64})\"\n| lookup threat_hashes indicator as sha256 OUTPUT threat_type, malware_family\n| where isnotnull(threat_type)\n| table _time, User, ParentImage, Image, CommandLine, malware_family</code></pre>"
      },
      {
        "title": "Performance Considerations",
        "body": "<h4>Order Matters</h4><p>Filter before expanding for multi-field checks:</p><pre><code>index=firewall action=allowed direction=outbound earliest=-1h\n| lookup threat_ips indicator as dest_ip OUTPUT threat_type\n| where isnotnull(threat_type)</code></pre><h4>Avoid Unnecessary Lookups</h4><pre><code>index=firewall\n| where NOT cidrmatch(\"10.0.0.0/8\", dest_ip)\n| where NOT cidrmatch(\"192.168.0.0/16\", dest_ip)\n| lookup threat_ips indicator as dest_ip OUTPUT threat_type</code></pre><h4>Use Summary Indexes for Large-Scale Matching</h4><pre><code>| tstats count where index=firewall by dest_ip\n| lookup threat_ips indicator as dest_ip OUTPUT threat_type\n| where isnotnull(threat_type)</code></pre><h4>Batch Processing for Historical Sweeps</h4><pre><code>| inputlookup threat_ips.csv\n| fields indicator\n| map maxsearches=100 search=\"index=firewall dest_ip=$indicator$ earliest=-30d | stats count, min(_time) as first_seen, max(_time) as last_seen by dest_ip\"\n| where count > 0</code></pre>"
      },
      {
        "title": "Summary",
        "body": "<p>Key multi-field matching techniques:</p><ul><li><strong>Sequential lookups</strong>: Separate lookup calls for each field</li><li><strong>CIDR matching</strong>: Configure match_type=CIDR for IP ranges</li><li><strong>Wildcard domains</strong>: Use WILDCARD match_type for domain patterns</li><li><strong>Coalesce patterns</strong>: Create unified field for universal matching</li><li><strong>mvexpand</strong>: Check all values in a multivalue field</li><li><strong>Source-specific</strong>: Custom patterns for DNS, email, endpoint data</li></ul><p>Comprehensive TI matching requires checking all relevant fields while maintaining acceptable performance.</p>"
      }
    ]
  }
}
